{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 Nightly Version You're currently on a nightly version branch. If you're only interested in the latest stable version, please click here . drasyl is an open-source general-purpose overlay network framework for rapid development of distributed P2P applications. By using drasyl developers can fully concentrate on creating distributed applications. With drasyl, boundaries between IP-based networks will be eliminated and secure communication channels between any two nodes will be provided. Zero-configuration is required to use drasyl. Developers can run a new drasyl node without having to write configuration files or provide IP addresses of other peers. Info As drasyl is primarily developed for the research project Smart Networks for Urban Participation (SANE) and focuses on functionalities necessary for the project. However, drasyl is open to contributions made by the community.","title":"Welcome"},{"location":"#welcome","text":"Nightly Version You're currently on a nightly version branch. If you're only interested in the latest stable version, please click here . drasyl is an open-source general-purpose overlay network framework for rapid development of distributed P2P applications. By using drasyl developers can fully concentrate on creating distributed applications. With drasyl, boundaries between IP-based networks will be eliminated and secure communication channels between any two nodes will be provided. Zero-configuration is required to use drasyl. Developers can run a new drasyl node without having to write configuration files or provide IP addresses of other peers. Info As drasyl is primarily developed for the research project Smart Networks for Urban Participation (SANE) and focuses on functionalities necessary for the project. However, drasyl is open to contributions made by the community.","title":"Welcome"},{"location":"cli/","text":"Command Line Tool \u00b6 It is possible to run drasyl from the command line using the drasyl command. The drasyl command makes it possible to start up drasyl nodes, generate identities, and more directly from the command line. You can download the drasyl command from GitHub . The download includes a bin/drasyl executable for Linux/macOS users and a bin/drasyl.bat for Windows users. Run drasyl help to get an overview of available commands and flags: $ drasyl help Usage: drasyl [flags] drasyl [command] Available Commands: help Show help for drasyl commands and flags. node Run a drasyl node. genidentity Generate and output new Identity. wormhole Transfer a text message from one node to another, safely. version Show the version number. Flags: -c,--config <file> Load configuration from specified file (default: /Users/heiko/drasyl.conf). -h,--help Show this help. -v,--verbose <level> Sets the log level (off, error, warn, info, debug, trace; default: warn) Use \"drasyl [command] --help\" for more information about a command. Docker \u00b6 The drasyl/drasyl image provides the drasyl command to the host. So no need to install drasyl on your machine, you can just use this docker image. For instance: $ docker run -i -t drasyl/drasyl version drasyl v0.2.0 (ef906c1) - os.name Linux - os.version 4.19.76-linuxkit - os.arch amd64 - java.version 11.0.8 To run a node: # generate an identity (this can take some time) $ docker run -i -t drasyl/drasyl genidentity | grep -v \"WARNING:\" > drasyl.identity.json # start a node $ docker run -i -t -p 22527:22527 \\ -v $PWD/drasyl.identity.json:/drasyl.identity.json \\ drasyl/drasyl node This command passes the just generated identity to the docker container and then launch the drasyl node command. Homebrew \u00b6 The drasyl command can also be downloaded with Homebrew : $ brew install drasyl-ovrlay/drasyl/drasyl","title":"Command Line Tool"},{"location":"cli/#command-line-tool","text":"It is possible to run drasyl from the command line using the drasyl command. The drasyl command makes it possible to start up drasyl nodes, generate identities, and more directly from the command line. You can download the drasyl command from GitHub . The download includes a bin/drasyl executable for Linux/macOS users and a bin/drasyl.bat for Windows users. Run drasyl help to get an overview of available commands and flags: $ drasyl help Usage: drasyl [flags] drasyl [command] Available Commands: help Show help for drasyl commands and flags. node Run a drasyl node. genidentity Generate and output new Identity. wormhole Transfer a text message from one node to another, safely. version Show the version number. Flags: -c,--config <file> Load configuration from specified file (default: /Users/heiko/drasyl.conf). -h,--help Show this help. -v,--verbose <level> Sets the log level (off, error, warn, info, debug, trace; default: warn) Use \"drasyl [command] --help\" for more information about a command.","title":"Command Line Tool"},{"location":"cli/#docker","text":"The drasyl/drasyl image provides the drasyl command to the host. So no need to install drasyl on your machine, you can just use this docker image. For instance: $ docker run -i -t drasyl/drasyl version drasyl v0.2.0 (ef906c1) - os.name Linux - os.version 4.19.76-linuxkit - os.arch amd64 - java.version 11.0.8 To run a node: # generate an identity (this can take some time) $ docker run -i -t drasyl/drasyl genidentity | grep -v \"WARNING:\" > drasyl.identity.json # start a node $ docker run -i -t -p 22527:22527 \\ -v $PWD/drasyl.identity.json:/drasyl.identity.json \\ drasyl/drasyl node This command passes the just generated identity to the docker container and then launch the drasyl node command.","title":"Docker"},{"location":"cli/#homebrew","text":"The drasyl command can also be downloaded with Homebrew : $ brew install drasyl-ovrlay/drasyl/drasyl","title":"Homebrew"},{"location":"contributing/","text":"Contributing \u00b6 The following resources can help if you want to contribute to drasyl: Contribution Guide Issue Tracker Ideas for future Features (german)","title":"Contributing"},{"location":"contributing/#contributing","text":"The following resources can help if you want to contribute to drasyl: Contribution Guide Issue Tracker Ideas for future Features (german)","title":"Contributing"},{"location":"getting-started/","text":"Getting Started \u00b6 Nightly Version You're currently on a nightly version branch. If you're only interested in the latest stable version, please click here . This guide describes the necessary steps to create your first drasyl node and how to integrate it into your application. Once the node is set up, it and therefore your application can participate in the drasyl Overlay Network and communicate with other nodes and applications. Add Dependency \u00b6 Create a new maven project and add the dependency to your pom.xml : Maven: <repositories> <repository> <id>oss.sonatype.org-snapshot</id> <url>https://oss.sonatype.org/content/repositories/snapshots/</url> <releases> <enabled>false</enabled> </releases> <snapshots> <enabled>true</enabled> </snapshots> </repository> </repositories> <dependency> <groupId>org.drasyl</groupId> <artifactId>drasyl-core</artifactId> <version>0.4.0-SNAPSHOT</version> </dependency> Other dependency managers: Gradle : compile \"org.drasyl:drasyl-core:0.4.0-SNAPSHOT\" // build.gradle Ivy : <dependency org=\"org.drasyl\" name=\"drasyl-core\" rev=\"0.4.0-SNAPSHOT\" conf=\"build\" /> // ivy.xml SBT : libraryDependencies += \"org.drasyl\" % \"drasyl-core\" % \"0.4.0-SNAPSHOT\" // build.sbt Implementing DrasylNode \u00b6 Next, you can create your own drasyl node by implementing DrasylNode . This class contains the following methods that are now relevant for you: send(...) : allows your application to send arbitrary messages to other drasyl nodes. onEvent(...) : allows your application to react to certain events (e.g. process received messages). This method must be implemented. start() : starts the node, which will then automatically connect to the drasyl network. shutdown() : disconnects from the drasyl network and shuts down the node. Here you can see a minimal working example of a node that forwards all received events to System.out : DrasylNode node = new DrasylNode() { @Override public void onEvent(Event event) { System.out.println(\"Event received: \" + event); } }; Node Events \u00b6 As mentioned before, different events are received by the application. These provide information about the state of your node, received messages or connections to other nodes. It is therefore important that you become familiar with the definitions and implications of the different event types. For example, you should listen for NodeOnlineEvent before start sending messages, and pause when NodeOfflineEvent has been received. Advanced References If you are interested in the life cycle of the individual events, you can find a state diagram here . Sending Messages \u00b6 Every message that is to be sent requires a recipient address. Each drasyl node creates an identity at its first startup consisting of a cryptographic public-private key pair. From the public key, a 10 hex digit address is derived, by which each node can be uniquely identified. The send() method needs the recipient as first argument and the message payload as second argument. Example: CompletableFuture<Void> result = node.send(\"0229041b273dd5ee1c2bef2d77ae17dbd00d2f0a2e939e22d42ef1c4bf05147ea9\", \"Hello World\".getBytes()); The returned Future does not give any feedback on whether the message could be delivered. The future is successfully completed if the local node could deliver the message itself or forward it to a super peer. Otherwise the future is completed exceptionally. Advanced References The addresses of recipient nodes must be known, as drasyl-core has no function for querying available addresses. The Groups Plugin can be used to get automatically notified about nodes joining and leaving the network. Receiving Messages \u00b6 Each received message is announced by an MessageEvent to the application. The event contains a getters for the message's sender and payload. Example: ... public void onEvent(Event event) { if (event instanceof MessageEvent) { MessageEvent message = (MessageEvent) event; System.out.println(\"Message received from \" + message.getSender() + \" with payload \" + new String(message.getPayload())); } } ... Starting & Stopping the drasyl Node \u00b6 Before you can use the drasyl node, you must start it using node.start() . For communication with other nodes in the local network, the node starts a server listening on port 22527. Make sure that the port is available. After the node has been successfully started, it emits an NodeUpEvent to the application. Then, once it has successfully connected to the overlay network, an NodeOnlineEvent is emitted. If the node is temporarily or permanently no longer needed, it can be shut down using node.shutdown() . A NodeDownEvent is emitted immediately after this call. The application should now no longer attempt to send messages. As soon as the connection to the drasyl network is terminated, an NodeOfflineEvent is emitted. A NodeNormalTerminationEvent is emitted when the shutdown is done. Summary \u00b6 In this chapter, we had a quick tour of drasyl with a demonstration on how to create a node, start and stop it, send messages, and process emitted events. Have a look at our examples to see how drasyl can be used for different scenarios.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"Nightly Version You're currently on a nightly version branch. If you're only interested in the latest stable version, please click here . This guide describes the necessary steps to create your first drasyl node and how to integrate it into your application. Once the node is set up, it and therefore your application can participate in the drasyl Overlay Network and communicate with other nodes and applications.","title":"Getting Started"},{"location":"getting-started/#add-dependency","text":"Create a new maven project and add the dependency to your pom.xml : Maven: <repositories> <repository> <id>oss.sonatype.org-snapshot</id> <url>https://oss.sonatype.org/content/repositories/snapshots/</url> <releases> <enabled>false</enabled> </releases> <snapshots> <enabled>true</enabled> </snapshots> </repository> </repositories> <dependency> <groupId>org.drasyl</groupId> <artifactId>drasyl-core</artifactId> <version>0.4.0-SNAPSHOT</version> </dependency> Other dependency managers: Gradle : compile \"org.drasyl:drasyl-core:0.4.0-SNAPSHOT\" // build.gradle Ivy : <dependency org=\"org.drasyl\" name=\"drasyl-core\" rev=\"0.4.0-SNAPSHOT\" conf=\"build\" /> // ivy.xml SBT : libraryDependencies += \"org.drasyl\" % \"drasyl-core\" % \"0.4.0-SNAPSHOT\" // build.sbt","title":"Add Dependency"},{"location":"getting-started/#implementing-drasylnode","text":"Next, you can create your own drasyl node by implementing DrasylNode . This class contains the following methods that are now relevant for you: send(...) : allows your application to send arbitrary messages to other drasyl nodes. onEvent(...) : allows your application to react to certain events (e.g. process received messages). This method must be implemented. start() : starts the node, which will then automatically connect to the drasyl network. shutdown() : disconnects from the drasyl network and shuts down the node. Here you can see a minimal working example of a node that forwards all received events to System.out : DrasylNode node = new DrasylNode() { @Override public void onEvent(Event event) { System.out.println(\"Event received: \" + event); } };","title":"Implementing DrasylNode"},{"location":"getting-started/#node-events","text":"As mentioned before, different events are received by the application. These provide information about the state of your node, received messages or connections to other nodes. It is therefore important that you become familiar with the definitions and implications of the different event types. For example, you should listen for NodeOnlineEvent before start sending messages, and pause when NodeOfflineEvent has been received. Advanced References If you are interested in the life cycle of the individual events, you can find a state diagram here .","title":"Node Events"},{"location":"getting-started/#sending-messages","text":"Every message that is to be sent requires a recipient address. Each drasyl node creates an identity at its first startup consisting of a cryptographic public-private key pair. From the public key, a 10 hex digit address is derived, by which each node can be uniquely identified. The send() method needs the recipient as first argument and the message payload as second argument. Example: CompletableFuture<Void> result = node.send(\"0229041b273dd5ee1c2bef2d77ae17dbd00d2f0a2e939e22d42ef1c4bf05147ea9\", \"Hello World\".getBytes()); The returned Future does not give any feedback on whether the message could be delivered. The future is successfully completed if the local node could deliver the message itself or forward it to a super peer. Otherwise the future is completed exceptionally. Advanced References The addresses of recipient nodes must be known, as drasyl-core has no function for querying available addresses. The Groups Plugin can be used to get automatically notified about nodes joining and leaving the network.","title":"Sending Messages"},{"location":"getting-started/#receiving-messages","text":"Each received message is announced by an MessageEvent to the application. The event contains a getters for the message's sender and payload. Example: ... public void onEvent(Event event) { if (event instanceof MessageEvent) { MessageEvent message = (MessageEvent) event; System.out.println(\"Message received from \" + message.getSender() + \" with payload \" + new String(message.getPayload())); } } ...","title":"Receiving Messages"},{"location":"getting-started/#starting-stopping-the-drasyl-node","text":"Before you can use the drasyl node, you must start it using node.start() . For communication with other nodes in the local network, the node starts a server listening on port 22527. Make sure that the port is available. After the node has been successfully started, it emits an NodeUpEvent to the application. Then, once it has successfully connected to the overlay network, an NodeOnlineEvent is emitted. If the node is temporarily or permanently no longer needed, it can be shut down using node.shutdown() . A NodeDownEvent is emitted immediately after this call. The application should now no longer attempt to send messages. As soon as the connection to the drasyl network is terminated, an NodeOfflineEvent is emitted. A NodeNormalTerminationEvent is emitted when the shutdown is done.","title":"Starting &amp; Stopping the drasyl Node"},{"location":"getting-started/#summary","text":"In this chapter, we had a quick tour of drasyl with a demonstration on how to create a node, start and stop it, send messages, and process emitted events. Have a look at our examples to see how drasyl can be used for different scenarios.","title":"Summary"},{"location":"public-super-peers/","text":"Public Super Peers \u00b6 Exposed drasyl nodes, configured as super peers and acting as rendezvous servers and relays, are required for discovery of other nodes. We run some public super peers, so you don't have to. Endpoint Network ID Used drasyl version wss://production.env.drasyl.org#025fff6f625f5dee816d9f8fe43895479aecfda187cb6a3330894a07e698bc5bd8 1 Latest stable release wss://staging.env.drasyl.org#03096ae3080a369829a44847d5af1f652bef3f9921e9e1bbad64970babe6d3c502 -25421 Latest nightly By default, all drasyl nodes are configured to use the super peer production.env.drasyl.org and network ID 1 .","title":"Public Super Peers"},{"location":"public-super-peers/#public-super-peers","text":"Exposed drasyl nodes, configured as super peers and acting as rendezvous servers and relays, are required for discovery of other nodes. We run some public super peers, so you don't have to. Endpoint Network ID Used drasyl version wss://production.env.drasyl.org#025fff6f625f5dee816d9f8fe43895479aecfda187cb6a3330894a07e698bc5bd8 1 Latest stable release wss://staging.env.drasyl.org#03096ae3080a369829a44847d5af1f652bef3f9921e9e1bbad64970babe6d3c502 -25421 Latest nightly By default, all drasyl nodes are configured to use the super peer production.env.drasyl.org and network ID 1 .","title":"Public Super Peers"},{"location":"architecture/concepts/","text":"Concepts \u00b6 In order to allow easy integration with arbitrary applications, the Overlay Network has a minimalist design. The main task is to provide transport channels between any nodes in the world. Exposed super peers are used to discover other nodes. If a direct connection between two nodes is not possible, the traffic is forwarded via a super peer. Each node generates an identity at the first start, through which the node can be uniquely addressed. The network gives no guarantee that messages sent will arrive, arrive in the correct order or arrive exactly once. Network Topology \u00b6 At startup the drasyl node connects to an always-present root node (the super peer). The super peer helps to discover other nodes and establish direct connections to other nodes. Peer Discovery \u00b6 drasyl uses different methods to find other peers. Peers running within a JVM are automatically discovered via shared memory. Local peers running in other JVMs on the same computer are found via the file system. Remote nodes are found using the Super Peer, which acts as a rendezvous server. Addressing \u00b6 Each node generates on the first start a unique identity consisting of a public/private key-pair and a proof of work (PoW). The public key is used to address the node. The PoW is required to prevent sybil attacks on the network by generating a large amount of identities. Currently a cpu-hard PoW is used. For the future a change to a memory-hard PoW is planned. Cryptography \u00b6 In a future release , messages wil be end-to-end encrypted. BPMN Diagrams \u00b6 We have created several BPMN diagrams for important components/processes within the overlay network Node Lifecycle Register at Super Peer Send, Relay & Receive Message Establish Direct Connection (P2P)","title":"Concepts"},{"location":"architecture/concepts/#concepts","text":"In order to allow easy integration with arbitrary applications, the Overlay Network has a minimalist design. The main task is to provide transport channels between any nodes in the world. Exposed super peers are used to discover other nodes. If a direct connection between two nodes is not possible, the traffic is forwarded via a super peer. Each node generates an identity at the first start, through which the node can be uniquely addressed. The network gives no guarantee that messages sent will arrive, arrive in the correct order or arrive exactly once.","title":"Concepts"},{"location":"architecture/concepts/#network-topology","text":"At startup the drasyl node connects to an always-present root node (the super peer). The super peer helps to discover other nodes and establish direct connections to other nodes.","title":"Network Topology"},{"location":"architecture/concepts/#peer-discovery","text":"drasyl uses different methods to find other peers. Peers running within a JVM are automatically discovered via shared memory. Local peers running in other JVMs on the same computer are found via the file system. Remote nodes are found using the Super Peer, which acts as a rendezvous server.","title":"Peer Discovery"},{"location":"architecture/concepts/#addressing","text":"Each node generates on the first start a unique identity consisting of a public/private key-pair and a proof of work (PoW). The public key is used to address the node. The PoW is required to prevent sybil attacks on the network by generating a large amount of identities. Currently a cpu-hard PoW is used. For the future a change to a memory-hard PoW is planned.","title":"Addressing"},{"location":"architecture/concepts/#cryptography","text":"In a future release , messages wil be end-to-end encrypted.","title":"Cryptography"},{"location":"architecture/concepts/#bpmn-diagrams","text":"We have created several BPMN diagrams for important components/processes within the overlay network Node Lifecycle Register at Super Peer Send, Relay & Receive Message Establish Direct Connection (P2P)","title":"BPMN Diagrams"},{"location":"architecture/diagrams/","text":"Sequence Diagrams \u00b6 Node Events \u00b6 The state diagram below shows which events occur in which order during the lifetime of a drasyl node: stateDiagram-v2 state started <<fork>> [*] --> started started --> NodeUpEvent NodeUpEvent --> NodeDownEvent NodeUpEvent --> NodeOnlineEvent NodeOnlineEvent --> NodeOfflineEvent NodeOfflineEvent --> NodeOnlineEvent NodeOfflineEvent --> NodeDownEvent NodeOfflineEvent --> NodeIdentityCollisionEvent NodeUpEvent --> NodeIdentityCollisionEvent NodeIdentityCollisionEvent --> NodeOnlineEvent NodeIdentityCollisionEvent --> NodeDownEvent NodeDownEvent --> NodeNormalTerminationEvent started --> NodeUnrecoverableErrorEvent state join <<join>> NodeNormalTerminationEvent --> join NodeUnrecoverableErrorEvent --> join join --> [*] Client Server Communication \u00b6 sequenceDiagram Note over Client,Server: Session State: New par Session Request Client->>Server: JoinMessage alt Session Created Server-->>Client: WelcomeMessage alt Session Confirmed Client-->>Server: StatusMessage.OK Note over Client,Server: Session State: Established alt Serverside Close Server->>Client: QuitMessage.$REASON else Clientside Close Client->>Server: QuitMessage.$REASON end Note over Client,Server: Session State: Terminated else Session Declined Client-->>Server: ??? end else Session Declined Server-->>Client: ??? end and Healtcheck loop Every n Seconds Server->>Client: PingMessage Client-->>Server: PongMessage opt Ping Timeout Server->>Client: ConnectionExceptionMessage.PING_PONG end end end Peer Session States \u00b6 stateDiagram [*] --> Initialization Initialization --> Errored Initialization --> Active Active --> Errored Active --> Terminated Terminated --> [*] Errored --> [*]","title":"Diagrams"},{"location":"architecture/diagrams/#sequence-diagrams","text":"","title":"Sequence Diagrams"},{"location":"architecture/diagrams/#node-events","text":"The state diagram below shows which events occur in which order during the lifetime of a drasyl node: stateDiagram-v2 state started <<fork>> [*] --> started started --> NodeUpEvent NodeUpEvent --> NodeDownEvent NodeUpEvent --> NodeOnlineEvent NodeOnlineEvent --> NodeOfflineEvent NodeOfflineEvent --> NodeOnlineEvent NodeOfflineEvent --> NodeDownEvent NodeOfflineEvent --> NodeIdentityCollisionEvent NodeUpEvent --> NodeIdentityCollisionEvent NodeIdentityCollisionEvent --> NodeOnlineEvent NodeIdentityCollisionEvent --> NodeDownEvent NodeDownEvent --> NodeNormalTerminationEvent started --> NodeUnrecoverableErrorEvent state join <<join>> NodeNormalTerminationEvent --> join NodeUnrecoverableErrorEvent --> join join --> [*]","title":"Node Events"},{"location":"architecture/diagrams/#client-server-communication","text":"sequenceDiagram Note over Client,Server: Session State: New par Session Request Client->>Server: JoinMessage alt Session Created Server-->>Client: WelcomeMessage alt Session Confirmed Client-->>Server: StatusMessage.OK Note over Client,Server: Session State: Established alt Serverside Close Server->>Client: QuitMessage.$REASON else Clientside Close Client->>Server: QuitMessage.$REASON end Note over Client,Server: Session State: Terminated else Session Declined Client-->>Server: ??? end else Session Declined Server-->>Client: ??? end and Healtcheck loop Every n Seconds Server->>Client: PingMessage Client-->>Server: PongMessage opt Ping Timeout Server->>Client: ConnectionExceptionMessage.PING_PONG end end end","title":"Client Server Communication"},{"location":"architecture/diagrams/#peer-session-states","text":"stateDiagram [*] --> Initialization Initialization --> Errored Initialization --> Active Active --> Errored Active --> Terminated Terminated --> [*] Errored --> [*]","title":"Peer Session States"},{"location":"configuration/","text":"Configuration \u00b6 drasyl is designed to work with zero-configuration. However, some use cases (e.g. using an own super peer) require customization configurations. For this situation there are various parameters available to adjust the behavior of drasyl nodes. An overview of all available parameters, their purpose and default values can be found in the reference.conf file. Create custom configurations \u00b6 Because drasyl's configuration is based on Lightbend Config library , there are many ways to create custom configurations. Use DrasylConfig.Buidler \u00b6 With the DrasylConfig.Buidler class, configurations can be created within Java. This allows you to define individual configurations for each node. It is done by calling DrasylConfig.newBuilder() ... .build() . Available builder methods can be obtained from the Javadoc . Example: DrasylConfig config = DrasylConfig.newBuilder() .identityPath(Path.of(\"/Users/heiko/drasyl.identity.json\")) .networkId(-25421) .superPeerEndpoints(Set.of(Endpoint.of(\"wss://staging.env.drasyl.org#03096ae3080a369829a44847d5af1f652bef3f9921e9e1bbad64970babe6d3c502\"))) .serverEnabled(false) .build(); The resulting DrasylConfig object can now be passed to the DrasylNode constructor . Use application.conf file \u00b6 You can add a resource called application.conf to your java classpath to provide a custom config used by all your nodes. This file has to use the HOCON Syntax . The file only needs to contain the parameters you want to overwrite because it will be merged with the default values found in reference.conf . Example: drasyl.identity.path = /Users/heiko/drasyl.identity.json drasyl.network.id = -25421 drasyl.super-peer.endpoints = [\"wss://staging.env.drasyl.org#03096ae3080a369829a44847d5af1f652bef3f9921e9e1bbad64970babe6d3c502\"] drasyl.server.enabled = false Use environment variables \u00b6 By setting the JVM property -Dconfig.override_with_env_vars=true it is possible to override any configuration value using environment variables. With this option enabled only environment variables starting with CONFIG_FORCE_ are considered, and the name is mangled as follows: the prefix CONFIG_FORCE_ is stripped single underscore( _ ) is converted into a dot( . ) double underscore( __ ) is converted into a dash( - ) triple underscore( ___ ) is converted into a single underscore( _ ) i.e. The environment variable CONFIG_FORCE_a_b__c___d set the configuration key a.b-c_d Example: $ CONFIG_FORCE_drasyl_identity_path=/Users/heiko/drasyl.identity.json \\ CONFIG_FORCE_drasyl_network_id=-25421 \\ CONFIG_FORCE_drasyl_super__peer_endpoints_0=wss://staging.env.drasyl.org#03096ae3080a369829a44847d5af1f652bef3f9921e9e1bbad64970babe6d3c502 \\ CONFIG_FORCE_drasyl_server_enabled=false \\ your-application.jar Advanced References Further information regarding formatting can be taken directly from the configuration library that is used internally by drasyl: https://github.com/lightbend/config","title":"Overview"},{"location":"configuration/#configuration","text":"drasyl is designed to work with zero-configuration. However, some use cases (e.g. using an own super peer) require customization configurations. For this situation there are various parameters available to adjust the behavior of drasyl nodes. An overview of all available parameters, their purpose and default values can be found in the reference.conf file.","title":"Configuration"},{"location":"configuration/#create-custom-configurations","text":"Because drasyl's configuration is based on Lightbend Config library , there are many ways to create custom configurations.","title":"Create custom configurations"},{"location":"configuration/#use-drasylconfigbuidler","text":"With the DrasylConfig.Buidler class, configurations can be created within Java. This allows you to define individual configurations for each node. It is done by calling DrasylConfig.newBuilder() ... .build() . Available builder methods can be obtained from the Javadoc . Example: DrasylConfig config = DrasylConfig.newBuilder() .identityPath(Path.of(\"/Users/heiko/drasyl.identity.json\")) .networkId(-25421) .superPeerEndpoints(Set.of(Endpoint.of(\"wss://staging.env.drasyl.org#03096ae3080a369829a44847d5af1f652bef3f9921e9e1bbad64970babe6d3c502\"))) .serverEnabled(false) .build(); The resulting DrasylConfig object can now be passed to the DrasylNode constructor .","title":"Use DrasylConfig.Buidler"},{"location":"configuration/#use-applicationconf-file","text":"You can add a resource called application.conf to your java classpath to provide a custom config used by all your nodes. This file has to use the HOCON Syntax . The file only needs to contain the parameters you want to overwrite because it will be merged with the default values found in reference.conf . Example: drasyl.identity.path = /Users/heiko/drasyl.identity.json drasyl.network.id = -25421 drasyl.super-peer.endpoints = [\"wss://staging.env.drasyl.org#03096ae3080a369829a44847d5af1f652bef3f9921e9e1bbad64970babe6d3c502\"] drasyl.server.enabled = false","title":"Use application.conf file"},{"location":"configuration/#use-environment-variables","text":"By setting the JVM property -Dconfig.override_with_env_vars=true it is possible to override any configuration value using environment variables. With this option enabled only environment variables starting with CONFIG_FORCE_ are considered, and the name is mangled as follows: the prefix CONFIG_FORCE_ is stripped single underscore( _ ) is converted into a dot( . ) double underscore( __ ) is converted into a dash( - ) triple underscore( ___ ) is converted into a single underscore( _ ) i.e. The environment variable CONFIG_FORCE_a_b__c___d set the configuration key a.b-c_d Example: $ CONFIG_FORCE_drasyl_identity_path=/Users/heiko/drasyl.identity.json \\ CONFIG_FORCE_drasyl_network_id=-25421 \\ CONFIG_FORCE_drasyl_super__peer_endpoints_0=wss://staging.env.drasyl.org#03096ae3080a369829a44847d5af1f652bef3f9921e9e1bbad64970babe6d3c502 \\ CONFIG_FORCE_drasyl_server_enabled=false \\ your-application.jar Advanced References Further information regarding formatting can be taken directly from the configuration library that is used internally by drasyl: https://github.com/lightbend/config","title":"Use environment variables"},{"location":"configuration/marshalling/","text":"Marshalling \u00b6 drasyl can automatically (un-) marshall given objects. To prevent security risks through unrestricted marshalling, types and packages can be defined in the config that are handled automatically. Info Since version 0.3.0, drasyl differs between in- and outbound messages. marshalling.inbound.allowed-types / marshalling.outbound.allowed-types \u00b6 This property is a list of all types that are supported by the codec for the drasyl pipeline. With this list, a developer guarantees that all classes are secure and cannot be misused as a deserialization gadget in the context of the marshaller. A reckless implementation of a permitted class can leave the entire application and all executing machines vulnerable to remote code execution. Important An attacker is in general interested in all \"non-pure\" methods, which have promising side effects. A method is \"pure\" if: The execution of the function has no side effects, and the return value of the function depends only on the input parameters passed to the function. For example, a vulnerability could be a setter or getter that connects to a database. A vulnerable class is for example the ch.qos.logback.core.db.DriverManagerConnectionSource. An attacker can choose the URL arbitrarily. By calling getConnection, Server Side Request Forgery (SSRF) and DOS attacks can occur. You can find more about this in the following literature: Java Unmarshaller Security - Turning your data into code execution by Moritz Bechler Automated Discovery of Deserialization Gadget Chains by Ian Haken Marshalling Pickles by Chris Frohoff and Garbriel Lawrence marshalling.inbound.allow-all-primitives / marshalling.outbound.allow-all-primitives \u00b6 Whether Java's primitive data types should automatically be allowed. If this setting is activated, drasyl automatically (de-)serializes the types: java.lang.Boolean java.lang.Character java.lang.Byte java.lang.Short java.lang.Integer java.lang.Long java.lang.Float java.lang.Double java.lang.Void java.lang.Boolean#TYPE java.lang.Character#TYPE java.lang.Byte#TYPE java.lang.Short#TYPE java.lang.Integer#TYPE java.lang.Long#TYPE java.lang.Float#TYPE java.lang.Double#TYPE java.lang.Void#TYPE marshalling.inbound.allow-array-of-defined-types / marshalling.outbound.allow-array-of-defined-types \u00b6 Whether of all allowed data types their array representations should be allowed automatically. marshalling.inbound.allowed-packages / marshalling.outbound.allowed-packages \u00b6 A list of all packages whose classes automatically supported by the default codec of drasyl. Attention This setting should only be used in absolute exceptions. All classes in the given package are accepted by the standard codec and will try to (de-)serialize. If there is even one insecure implementation in the package, the whole application is vulnerable.","title":"Marshalling"},{"location":"configuration/marshalling/#marshalling","text":"drasyl can automatically (un-) marshall given objects. To prevent security risks through unrestricted marshalling, types and packages can be defined in the config that are handled automatically. Info Since version 0.3.0, drasyl differs between in- and outbound messages.","title":"Marshalling"},{"location":"configuration/marshalling/#marshallinginboundallowed-types-marshallingoutboundallowed-types","text":"This property is a list of all types that are supported by the codec for the drasyl pipeline. With this list, a developer guarantees that all classes are secure and cannot be misused as a deserialization gadget in the context of the marshaller. A reckless implementation of a permitted class can leave the entire application and all executing machines vulnerable to remote code execution. Important An attacker is in general interested in all \"non-pure\" methods, which have promising side effects. A method is \"pure\" if: The execution of the function has no side effects, and the return value of the function depends only on the input parameters passed to the function. For example, a vulnerability could be a setter or getter that connects to a database. A vulnerable class is for example the ch.qos.logback.core.db.DriverManagerConnectionSource. An attacker can choose the URL arbitrarily. By calling getConnection, Server Side Request Forgery (SSRF) and DOS attacks can occur. You can find more about this in the following literature: Java Unmarshaller Security - Turning your data into code execution by Moritz Bechler Automated Discovery of Deserialization Gadget Chains by Ian Haken Marshalling Pickles by Chris Frohoff and Garbriel Lawrence","title":"marshalling.inbound.allowed-types / marshalling.outbound.allowed-types"},{"location":"configuration/marshalling/#marshallinginboundallow-all-primitives-marshallingoutboundallow-all-primitives","text":"Whether Java's primitive data types should automatically be allowed. If this setting is activated, drasyl automatically (de-)serializes the types: java.lang.Boolean java.lang.Character java.lang.Byte java.lang.Short java.lang.Integer java.lang.Long java.lang.Float java.lang.Double java.lang.Void java.lang.Boolean#TYPE java.lang.Character#TYPE java.lang.Byte#TYPE java.lang.Short#TYPE java.lang.Integer#TYPE java.lang.Long#TYPE java.lang.Float#TYPE java.lang.Double#TYPE java.lang.Void#TYPE","title":"marshalling.inbound.allow-all-primitives / marshalling.outbound.allow-all-primitives"},{"location":"configuration/marshalling/#marshallinginboundallow-array-of-defined-types-marshallingoutboundallow-array-of-defined-types","text":"Whether of all allowed data types their array representations should be allowed automatically.","title":"marshalling.inbound.allow-array-of-defined-types / marshalling.outbound.allow-array-of-defined-types"},{"location":"configuration/marshalling/#marshallinginboundallowed-packages-marshallingoutboundallowed-packages","text":"A list of all packages whose classes automatically supported by the default codec of drasyl. Attention This setting should only be used in absolute exceptions. All classes in the given package are accepted by the standard codec and will try to (de-)serialize. If there is even one insecure implementation in the package, the whole application is vulnerable.","title":"marshalling.inbound.allowed-packages / marshalling.outbound.allowed-packages"},{"location":"plugins/groups/","text":"Groups \u00b6 With the groups Plugins nodes can organize themselves in groups. Members within the group will be automatically notified about the entry and exit of other nodes. Client \u00b6 The groups-client plugin enables nodes to join groups. Add Dependency \u00b6 Maven: <dependency> <groupId>org.drasyl</groupId> <artifactId>drasyl-plugin-groups-client</artifactId> <version>0.4.0-SNAPSHOT</version> </dependency> Other dependency managers: Gradle : compile \"org.drasyl:drasyl-plugin-groups-client:0.4.0-SNAPSHOT\" // build.gradle Ivy : <dependency org=\"org.drasyl\" name=\"drasyl-plugin-groups-client\" rev=\"0.4.0-SNAPSHOT\" conf=\"build\" /> // ivy.xml SBT : libraryDependencies += \"org.drasyl\" % \"drasyl-plugin-groups-client\" % \"0.4.0-SNAPSHOT\" // build.sbt Configuration \u00b6 Make sure that the following entry is included in your configuration under drasyl.plugins : \"org.drasyl.plugin.groups.client.GroupsClientPlugin\" { enabled = true groups = [ \"groups://my-shared-secret@023d34f317616c3bb0fa1e4b425e9419d1704ef57f6e53afe9790e00998134f5ff/steezy-vips?timeout=60\" ] } With this configuration, the client will connect to the Groups Manager on the node 023d34f317616c3bb0fa1e4b425e9419d1704ef57f6e53afe9790e00998134f5ff at startup and will join the group steezy-vips . Authentication is done via the shared secret my-shared-secret . Special Group Events will then inform you about group joins of your local or other nodes. In the next section you will learn how to start the Group Manager on a node. Manager \u00b6 The groups-manager allows a node to manage groups and their memberships. Add Dependency \u00b6 Maven: <dependency> <groupId>org.drasyl</groupId> <artifactId>drasyl-plugin-groups-manager</artifactId> <version>0.4.0-SNAPSHOT</version> </dependency> Other dependency managers: Gradle : compile \"org.drasyl:drasyl-plugin-groups-manager:0.4.0-SNAPSHOT\" // build.gradle Ivy : <dependency org=\"org.drasyl\" name=\"drasyl-plugin-groups-manager\" rev=\"0.4.0-SNAPSHOT\" conf=\"build\" /> // ivy.xml SBT : libraryDependencies += \"org.drasyl\" % \"drasyl-plugin-groups-manager\" % \"0.4.0-SNAPSHOT\" // build.sbt Configuration \u00b6 Make sure that the following entry is included in your configuration under drasyl.plugins : \"org.drasyl.plugin.groups.manager.GroupsManagerPlugin\" { enabled = true database { uri = \"jdbc:sqlite::memory:\" } groups { \"steezy-vips\" { secret = \"my-shared-secret\" } } } With this configuration the manager is created with the group steezy-vips , whose members must authenticate themselves using the shared secret my-shared-secret . The manager stores all groups, nodes and their memberships in memory. To persistent the data on file system, database.uri can be set to jdbc:sqlite:groups-manager.sqlite .","title":"drasyl Groups"},{"location":"plugins/groups/#groups","text":"With the groups Plugins nodes can organize themselves in groups. Members within the group will be automatically notified about the entry and exit of other nodes.","title":"Groups"},{"location":"plugins/groups/#client","text":"The groups-client plugin enables nodes to join groups.","title":"Client"},{"location":"plugins/groups/#add-dependency","text":"Maven: <dependency> <groupId>org.drasyl</groupId> <artifactId>drasyl-plugin-groups-client</artifactId> <version>0.4.0-SNAPSHOT</version> </dependency> Other dependency managers: Gradle : compile \"org.drasyl:drasyl-plugin-groups-client:0.4.0-SNAPSHOT\" // build.gradle Ivy : <dependency org=\"org.drasyl\" name=\"drasyl-plugin-groups-client\" rev=\"0.4.0-SNAPSHOT\" conf=\"build\" /> // ivy.xml SBT : libraryDependencies += \"org.drasyl\" % \"drasyl-plugin-groups-client\" % \"0.4.0-SNAPSHOT\" // build.sbt","title":"Add Dependency"},{"location":"plugins/groups/#configuration","text":"Make sure that the following entry is included in your configuration under drasyl.plugins : \"org.drasyl.plugin.groups.client.GroupsClientPlugin\" { enabled = true groups = [ \"groups://my-shared-secret@023d34f317616c3bb0fa1e4b425e9419d1704ef57f6e53afe9790e00998134f5ff/steezy-vips?timeout=60\" ] } With this configuration, the client will connect to the Groups Manager on the node 023d34f317616c3bb0fa1e4b425e9419d1704ef57f6e53afe9790e00998134f5ff at startup and will join the group steezy-vips . Authentication is done via the shared secret my-shared-secret . Special Group Events will then inform you about group joins of your local or other nodes. In the next section you will learn how to start the Group Manager on a node.","title":"Configuration"},{"location":"plugins/groups/#manager","text":"The groups-manager allows a node to manage groups and their memberships.","title":"Manager"},{"location":"plugins/groups/#add-dependency_1","text":"Maven: <dependency> <groupId>org.drasyl</groupId> <artifactId>drasyl-plugin-groups-manager</artifactId> <version>0.4.0-SNAPSHOT</version> </dependency> Other dependency managers: Gradle : compile \"org.drasyl:drasyl-plugin-groups-manager:0.4.0-SNAPSHOT\" // build.gradle Ivy : <dependency org=\"org.drasyl\" name=\"drasyl-plugin-groups-manager\" rev=\"0.4.0-SNAPSHOT\" conf=\"build\" /> // ivy.xml SBT : libraryDependencies += \"org.drasyl\" % \"drasyl-plugin-groups-manager\" % \"0.4.0-SNAPSHOT\" // build.sbt","title":"Add Dependency"},{"location":"plugins/groups/#configuration_1","text":"Make sure that the following entry is included in your configuration under drasyl.plugins : \"org.drasyl.plugin.groups.manager.GroupsManagerPlugin\" { enabled = true database { uri = \"jdbc:sqlite::memory:\" } groups { \"steezy-vips\" { secret = \"my-shared-secret\" } } } With this configuration the manager is created with the group steezy-vips , whose members must authenticate themselves using the shared secret my-shared-secret . The manager stores all groups, nodes and their memberships in memory. To persistent the data on file system, database.uri can be set to jdbc:sqlite:groups-manager.sqlite .","title":"Configuration"}]}