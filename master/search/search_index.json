{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 Nightly Version You're currently on a nightly version branch. If you're only interested in the latest stable version, please click here . drasyl is an open-source general-purpose overlay network framework for rapid development of distributed P2P applications. By using drasyl developers can fully concentrate on creating distributed applications. With drasyl boundaries between layer-2 networks will be eliminated and secure communication channels between any peers will be provided. Zero-configuration is required to use drasyl. Developers can run a new drasyl node without having to write configuration files or provide IP addresses of peers. Info As drasyl is primarily developed for the research project Smart Networks for Urban Participation (SANE) and focuses on functionalities necessary for the project. However, drasyl is open to contributions made by the community.","title":"Welcome"},{"location":"#welcome","text":"Nightly Version You're currently on a nightly version branch. If you're only interested in the latest stable version, please click here . drasyl is an open-source general-purpose overlay network framework for rapid development of distributed P2P applications. By using drasyl developers can fully concentrate on creating distributed applications. With drasyl boundaries between layer-2 networks will be eliminated and secure communication channels between any peers will be provided. Zero-configuration is required to use drasyl. Developers can run a new drasyl node without having to write configuration files or provide IP addresses of peers. Info As drasyl is primarily developed for the research project Smart Networks for Urban Participation (SANE) and focuses on functionalities necessary for the project. However, drasyl is open to contributions made by the community.","title":"Welcome"},{"location":"architecture/concepts/","text":"Concepts \u00b6 In order to allow easy integration with arbitrary applications, the Overlay Network has a minimalist design. The main task is to provide transport channels between any nodes in the world. Exposed super peers are used to discover other nodes. If a direct connection between two nodes is not possible, the traffic is forwarded via a super peer. Each node generates an identity at the first start, through which the node can be uniquely addressed. The network gives no guarantee that messages sent will arrive, arrive in the correct order or arrive exactly once. Network Topology \u00b6 At startup the drasyl node connects to an always-present root node (the super peer). The super peer helps to discover other nodes and establish direct connections to other nodes. Peer Discovery \u00b6 drasyl uses different methods to find other peers. Peers running within a JVM are automatically discovered via shared memory. In a future release local peers running in other JVMs on the same computer are found via the file system. Remote nodes are found using the Super Peer, which acts as a rendezvous server. Nodes always try to communicate with each other via a direct connection. If this is not possible, messages are relayed through the super peer. Currently, direct connections are only possible for nodes within the same local network. In a future release , direct connections across networks are planned] using NAT traversal techniques. Addressing \u00b6 Each node generates on the first start a unique identity consisting of a public/private key-pair and a proof of work (PoW). The public key is used to address the node. The PoW is required to prevent sybil attacks on the network by generating a large amount of identities. Currently a cpu-hard PoW is used. For the future a change to a memory-hard PoW is planned. Cryptography \u00b6 In a future release , messages wil be end-to-end encrypted. BPMN Diagrams \u00b6 We have created several BPMN diagrams for important components/processes within the overlay network Node Lifecycle Register at Super Peer Send, Relay & Receive Message Establish Direct Connection (P2P)","title":"Concepts"},{"location":"architecture/concepts/#concepts","text":"In order to allow easy integration with arbitrary applications, the Overlay Network has a minimalist design. The main task is to provide transport channels between any nodes in the world. Exposed super peers are used to discover other nodes. If a direct connection between two nodes is not possible, the traffic is forwarded via a super peer. Each node generates an identity at the first start, through which the node can be uniquely addressed. The network gives no guarantee that messages sent will arrive, arrive in the correct order or arrive exactly once.","title":"Concepts"},{"location":"architecture/concepts/#network-topology","text":"At startup the drasyl node connects to an always-present root node (the super peer). The super peer helps to discover other nodes and establish direct connections to other nodes.","title":"Network Topology"},{"location":"architecture/concepts/#peer-discovery","text":"drasyl uses different methods to find other peers. Peers running within a JVM are automatically discovered via shared memory. In a future release local peers running in other JVMs on the same computer are found via the file system. Remote nodes are found using the Super Peer, which acts as a rendezvous server. Nodes always try to communicate with each other via a direct connection. If this is not possible, messages are relayed through the super peer. Currently, direct connections are only possible for nodes within the same local network. In a future release , direct connections across networks are planned] using NAT traversal techniques.","title":"Peer Discovery"},{"location":"architecture/concepts/#addressing","text":"Each node generates on the first start a unique identity consisting of a public/private key-pair and a proof of work (PoW). The public key is used to address the node. The PoW is required to prevent sybil attacks on the network by generating a large amount of identities. Currently a cpu-hard PoW is used. For the future a change to a memory-hard PoW is planned.","title":"Addressing"},{"location":"architecture/concepts/#cryptography","text":"In a future release , messages wil be end-to-end encrypted.","title":"Cryptography"},{"location":"architecture/concepts/#bpmn-diagrams","text":"We have created several BPMN diagrams for important components/processes within the overlay network Node Lifecycle Register at Super Peer Send, Relay & Receive Message Establish Direct Connection (P2P)","title":"BPMN Diagrams"},{"location":"architecture/diagrams/","text":"Sequence Diagrams \u00b6 Node Events \u00b6 The state diagram below shows which events occur in which order during the lifetime of a drasyl node: stateDiagram-v2 state started <<fork>> [*] --> started started --> NodeUpEvent NodeUpEvent --> NodeDownEvent NodeUpEvent --> NodeOnlineEvent NodeOnlineEvent --> NodeOfflineEvent NodeOfflineEvent --> NodeOnlineEvent NodeOfflineEvent --> NodeDownEvent NodeOfflineEvent --> NodeIdentityCollisionEvent NodeUpEvent --> NodeIdentityCollisionEvent NodeIdentityCollisionEvent --> NodeOnlineEvent NodeIdentityCollisionEvent --> NodeDownEvent NodeDownEvent --> NodeNormalTerminationEvent started --> NodeUnrecoverableErrorEvent state join <<join>> NodeNormalTerminationEvent --> join NodeUnrecoverableErrorEvent --> join join --> [*] Client Server Communication \u00b6 sequenceDiagram Note over Client,Server: Session State: New par Session Request Client->>Server: JoinMessage alt Session Created Server-->>Client: WelcomeMessage alt Session Confirmed Client-->>Server: StatusMessage.OK Note over Client,Server: Session State: Established alt Serverside Close Server->>Client: QuitMessage.$REASON else Clientside Close Client->>Server: QuitMessage.$REASON end Note over Client,Server: Session State: Terminated else Session Declined Client-->>Server: ??? end else Session Declined Server-->>Client: ??? end and Healtcheck loop Every n Seconds Server->>Client: PingMessage Client-->>Server: PongMessage opt Ping Timeout Server->>Client: ConnectionExceptionMessage.PING_PONG end end end Peer Session States \u00b6 stateDiagram [*] --> Initialization Initialization --> Errored Initialization --> Active Active --> Errored Active --> Terminated Terminated --> [*] Errored --> [*]","title":"Diagrams"},{"location":"architecture/diagrams/#sequence-diagrams","text":"","title":"Sequence Diagrams"},{"location":"architecture/diagrams/#node-events","text":"The state diagram below shows which events occur in which order during the lifetime of a drasyl node: stateDiagram-v2 state started <<fork>> [*] --> started started --> NodeUpEvent NodeUpEvent --> NodeDownEvent NodeUpEvent --> NodeOnlineEvent NodeOnlineEvent --> NodeOfflineEvent NodeOfflineEvent --> NodeOnlineEvent NodeOfflineEvent --> NodeDownEvent NodeOfflineEvent --> NodeIdentityCollisionEvent NodeUpEvent --> NodeIdentityCollisionEvent NodeIdentityCollisionEvent --> NodeOnlineEvent NodeIdentityCollisionEvent --> NodeDownEvent NodeDownEvent --> NodeNormalTerminationEvent started --> NodeUnrecoverableErrorEvent state join <<join>> NodeNormalTerminationEvent --> join NodeUnrecoverableErrorEvent --> join join --> [*]","title":"Node Events"},{"location":"architecture/diagrams/#client-server-communication","text":"sequenceDiagram Note over Client,Server: Session State: New par Session Request Client->>Server: JoinMessage alt Session Created Server-->>Client: WelcomeMessage alt Session Confirmed Client-->>Server: StatusMessage.OK Note over Client,Server: Session State: Established alt Serverside Close Server->>Client: QuitMessage.$REASON else Clientside Close Client->>Server: QuitMessage.$REASON end Note over Client,Server: Session State: Terminated else Session Declined Client-->>Server: ??? end else Session Declined Server-->>Client: ??? end and Healtcheck loop Every n Seconds Server->>Client: PingMessage Client-->>Server: PongMessage opt Ping Timeout Server->>Client: ConnectionExceptionMessage.PING_PONG end end end","title":"Client Server Communication"},{"location":"architecture/diagrams/#peer-session-states","text":"stateDiagram [*] --> Initialization Initialization --> Errored Initialization --> Active Active --> Errored Active --> Terminated Terminated --> [*] Errored --> [*]","title":"Peer Session States"},{"location":"configuration/","text":"Configuration \u00b6 drasyl is designed to work with zero-configuration. However, some use cases require configuration customization. There are many ways to customize the drasyl (e.g. via environment variables, config file, start parameters, DrasylConfig.Builder class) The following example shows the usage of the DrasyConfig.Builder : DrasylConfig config = DrasylConfig.newBuilder() .loglevel(Level.DEBUG) .serverEnabled(false) .build(); The created DrasylConfig object can then be passed to the DrasylNode constructor. An overview of all available configuration parameters are discussed in the following. Further information regarding formatting can be taken directly from the configuration library that is used internally by drasyl: https://github.com/lightbend/config","title":"Overview"},{"location":"configuration/#configuration","text":"drasyl is designed to work with zero-configuration. However, some use cases require configuration customization. There are many ways to customize the drasyl (e.g. via environment variables, config file, start parameters, DrasylConfig.Builder class) The following example shows the usage of the DrasyConfig.Builder : DrasylConfig config = DrasylConfig.newBuilder() .loglevel(Level.DEBUG) .serverEnabled(false) .build(); The created DrasylConfig object can then be passed to the DrasylNode constructor. An overview of all available configuration parameters are discussed in the following. Further information regarding formatting can be taken directly from the configuration library that is used internally by drasyl: https://github.com/lightbend/config","title":"Configuration"},{"location":"configuration/marshalling/","text":"Marshalling \u00b6 drasyl can automatically (un-) marshall given objects. To prevent security risks through unrestricted marshalling, types and packages can be defined in the config that are handled automatically. Info Since version 3, drasyl differs between in- and outbound messages. marshalling.inbound.allowed-types / marshalling.outbound.allowed-types \u00b6 This property is a list of all types that are supported by the codec for the drasyl pipeline. With this list, a developer guarantees that all classes are secure and cannot be misused as a deserialization gadget in the context of the marshaller. A reckless implementation of a permitted class can leave the entire application and all executing machines vulnerable to remote code execution. Info An attacker is in general interested in all \"non-pure\" methods, which have promising side effects. A method is \"pure\" if: The execution of the function has no side effects, and the return value of the function depends only on the input parameters passed to the function. For example, a vulnerability could be a setter or getter that connects to a database. A vulnerable class is for example the ch.qos.logback.core.db.DriverManagerConnectionSource. An attacker can choose the URL arbitrarily. By calling getConnection, Server Side Request Forgery (SSRF) and DOS attacks can occur. You can find more about this in the following literature: Java Unmarshaller Security - Turning your data into code execution by Moritz Bechler Automated Discovery of Deserialization Gadget Chains by Ian Haken Marshalling Pickles by Chris Frohoff and Garbriel Lawrence marshalling.inbound.allow-all-primitives / marshalling.outbound.allow-all-primitives \u00b6 Whether Java's primitive data types should automatically be allowed. If this setting is activated, drasyl automatically (de-)serializes the types: java.lang.Boolean java.lang.Character java.lang.Byte java.lang.Short java.lang.Integer java.lang.Long java.lang.Float java.lang.Double java.lang.Void java.lang.Boolean#TYPE java.lang.Character#TYPE java.lang.Byte#TYPE java.lang.Short#TYPE java.lang.Integer#TYPE java.lang.Long#TYPE java.lang.Float#TYPE java.lang.Double#TYPE java.lang.Void#TYPE marshalling.inbound.allow-array-of-defined-types / marshalling.outbound.allow-array-of-defined-types \u00b6 Whether of all allowed data types their array representations should be allowed automatically. marshalling.inbound.allowed-packages / marshalling.outbound.allowed-packages \u00b6 A list of all packages whose classes automatically supported by the default codec of drasyl. Attention This setting should only be used in absolute exceptions. All classes in the given package are accepted by the standard codec and will try to (de-)serialize. If there is even one insecure implementation in the package, the whole application is vulnerable.","title":"Marshalling"},{"location":"configuration/marshalling/#marshalling","text":"drasyl can automatically (un-) marshall given objects. To prevent security risks through unrestricted marshalling, types and packages can be defined in the config that are handled automatically. Info Since version 3, drasyl differs between in- and outbound messages.","title":"Marshalling"},{"location":"configuration/marshalling/#marshallinginboundallowed-types-marshallingoutboundallowed-types","text":"This property is a list of all types that are supported by the codec for the drasyl pipeline. With this list, a developer guarantees that all classes are secure and cannot be misused as a deserialization gadget in the context of the marshaller. A reckless implementation of a permitted class can leave the entire application and all executing machines vulnerable to remote code execution. Info An attacker is in general interested in all \"non-pure\" methods, which have promising side effects. A method is \"pure\" if: The execution of the function has no side effects, and the return value of the function depends only on the input parameters passed to the function. For example, a vulnerability could be a setter or getter that connects to a database. A vulnerable class is for example the ch.qos.logback.core.db.DriverManagerConnectionSource. An attacker can choose the URL arbitrarily. By calling getConnection, Server Side Request Forgery (SSRF) and DOS attacks can occur. You can find more about this in the following literature: Java Unmarshaller Security - Turning your data into code execution by Moritz Bechler Automated Discovery of Deserialization Gadget Chains by Ian Haken Marshalling Pickles by Chris Frohoff and Garbriel Lawrence","title":"marshalling.inbound.allowed-types / marshalling.outbound.allowed-types"},{"location":"configuration/marshalling/#marshallinginboundallow-all-primitives-marshallingoutboundallow-all-primitives","text":"Whether Java's primitive data types should automatically be allowed. If this setting is activated, drasyl automatically (de-)serializes the types: java.lang.Boolean java.lang.Character java.lang.Byte java.lang.Short java.lang.Integer java.lang.Long java.lang.Float java.lang.Double java.lang.Void java.lang.Boolean#TYPE java.lang.Character#TYPE java.lang.Byte#TYPE java.lang.Short#TYPE java.lang.Integer#TYPE java.lang.Long#TYPE java.lang.Float#TYPE java.lang.Double#TYPE java.lang.Void#TYPE","title":"marshalling.inbound.allow-all-primitives / marshalling.outbound.allow-all-primitives"},{"location":"configuration/marshalling/#marshallinginboundallow-array-of-defined-types-marshallingoutboundallow-array-of-defined-types","text":"Whether of all allowed data types their array representations should be allowed automatically.","title":"marshalling.inbound.allow-array-of-defined-types / marshalling.outbound.allow-array-of-defined-types"},{"location":"configuration/marshalling/#marshallinginboundallowed-packages-marshallingoutboundallowed-packages","text":"A list of all packages whose classes automatically supported by the default codec of drasyl. Attention This setting should only be used in absolute exceptions. All classes in the given package are accepted by the standard codec and will try to (de-)serialize. If there is even one insecure implementation in the package, the whole application is vulnerable.","title":"marshalling.inbound.allowed-packages / marshalling.outbound.allowed-packages"},{"location":"contributing/submitting_issues/","text":"Submitting Issues \u00b6 Bugs \u00b6 When filing an issue , please include the following information if possible as well as a description of the problem. Make sure you test with the latest snapshot version of drasyl : drasyl version Expected behavior Actual behavior Steps to reproduce Bonus points: provide a minimal working example Getting Help Vs Reporting an Issue The issue tracker is not a general support forum, but a place to report bugs and asks for new features. For end-user related support questions, try using first: the drasyl element room: Feature Requests \u00b6 Please use our template for feature requests.","title":"Submitting Issues"},{"location":"contributing/submitting_issues/#submitting-issues","text":"","title":"Submitting Issues"},{"location":"contributing/submitting_issues/#bugs","text":"When filing an issue , please include the following information if possible as well as a description of the problem. Make sure you test with the latest snapshot version of drasyl : drasyl version Expected behavior Actual behavior Steps to reproduce Bonus points: provide a minimal working example Getting Help Vs Reporting an Issue The issue tracker is not a general support forum, but a place to report bugs and asks for new features. For end-user related support questions, try using first: the drasyl element room:","title":"Bugs"},{"location":"contributing/submitting_issues/#feature-requests","text":"Please use our template for feature requests.","title":"Feature Requests"},{"location":"contributing/submitting_pull_request/","text":"Submitting a pull request/merge request \u00b6 If you find a bug that you'd like to fix, or a new feature that you'd like to implement then please submit a pull request/merge request. If it is a big feature then make an issue first so it can be discussed. First, create a fork via GitHub's/GitLab's Web Interface. Now in your terminal, git clone your fork. And get hacking. Make sure you Use the drasyl code style Add changelog entry Add documentation for a new feature. Add tests for a new feature. squash commits down to one per feature. rebase to master with git rebase master When ready - run the tests mvn test When you are done with that git push your changes. Go to the GitHub/GitLab website and click \"New pull request/merge request\". Your patch will get reviewed and you might get asked to fix some stuff. If so, then make the changes in the same branch, squash the commits (make multiple commits one commit) by running: git log # See how many commits you want to squash git reset --soft HEAD~2 # This squashes the 2 latest commits together. git status # Check what will happen, if you made a mistake resetting, you can run git reset 'HEAD@{1}' to undo. git commit # Add a new commit message. git push --force # Push the squashed commit to your fork repo.","title":"Submiting PRs"},{"location":"contributing/submitting_pull_request/#submitting-a-pull-requestmerge-request","text":"If you find a bug that you'd like to fix, or a new feature that you'd like to implement then please submit a pull request/merge request. If it is a big feature then make an issue first so it can be discussed. First, create a fork via GitHub's/GitLab's Web Interface. Now in your terminal, git clone your fork. And get hacking. Make sure you Use the drasyl code style Add changelog entry Add documentation for a new feature. Add tests for a new feature. squash commits down to one per feature. rebase to master with git rebase master When ready - run the tests mvn test When you are done with that git push your changes. Go to the GitHub/GitLab website and click \"New pull request/merge request\". Your patch will get reviewed and you might get asked to fix some stuff. If so, then make the changes in the same branch, squash the commits (make multiple commits one commit) by running: git log # See how many commits you want to squash git reset --soft HEAD~2 # This squashes the 2 latest commits together. git status # Check what will happen, if you made a mistake resetting, you can run git reset 'HEAD@{1}' to undo. git commit # Add a new commit message. git push --force # Push the squashed commit to your fork repo.","title":"Submitting a pull request/merge request"},{"location":"getting-started/cli/","text":"Command Line Interface \u00b6 There is a drasyl command line interface with some utilities that can be found on the releases page: https://github.com/drasyl-overlay/drasyl/releases It is also available in docker: docker run drasyl/drasyl help","title":"CLI"},{"location":"getting-started/cli/#command-line-interface","text":"There is a drasyl command line interface with some utilities that can be found on the releases page: https://github.com/drasyl-overlay/drasyl/releases It is also available in docker: docker run drasyl/drasyl help","title":"Command Line Interface"},{"location":"getting-started/quick-start/","text":"Quick Start \u00b6 Nightly Version You're currently on a nightly version branch. If you're only interested in the latest stable version, please click here . This guide describes the necessary steps to create your first drasyl node and how to integrate it into your application. Once the node is set up, it and therefore your application can participate in the drasyl Overlay Network and communicate with other nodes and applications. Add Snapshot Repository \u00b6 <repositories> <repository> <id>oss.sonatype.org-snapshot</id> <url>https://oss.sonatype.org/content/repositories/snapshots/</url> <releases> <enabled>false</enabled> </releases> <snapshots> <enabled>true</enabled> </snapshots> </repository> </repositories> Add Dependency \u00b6 Maven: <dependency> <groupId>org.drasyl</groupId> <artifactId>drasyl-core</artifactId> <version>0.2.1-SNAPSHOT</version> </dependency> Gradle: compile group: 'org.drasyl', name: 'drasyl-core', version: '0.2.1-SNAPSHOT' Implementing DrasylNode \u00b6 Next, you can create your own drasyl node by implementing DrasylNode . This class contains the following methods that are now relevant for you: send(...) : allows your application to send arbitrary messages to other drasyl nodes. onEvent(...) : allows your application to react to certain events (e.g. process received messages). This method must be implemented. start() : starts the node, which will then automatically connect to the drasyl network. shutdown() : disconnects from the drasyl network and shuts down the node. Here you can see a minimal working example of a node that forwards all received events to System.out : DrasylNode node = new DrasylNode() { @Override public void onEvent(Event event) { System.out.println(\"Event received: \" + event); } }; Node Events \u00b6 As mentioned before, different events are received by the application. These provide information about the state of your node, received messages or connections to other nodes. It is therefore important that you become familiar with the definitions and implications of the different event types. For example, you should listen for NodeOnlineEvent before start sending messages, and pause when NodeOfflineEvent has been received. Advanced References If you are interested in the life cycle of the individual events, you can find a state diagram here . Sending Messages \u00b6 Every message that is to be sent requires a recipient address. Each drasyl node creates an identity at its first startup consisting of a cryptographic public-private key pair. From the public key, a 10 hex digit address is derived, by which each node can be uniquely identified. Currently, addresses of recipient nodes must be known, as drasyl currently has no function for querying available addresses. The send() method needs the recipient as first argument and the message payload as second argument. Example node.send(\"0229041b273dd5ee1c2bef2d77ae17dbd00d2f0a2e939e22d42ef1c4bf05147ea9\", \"Hello World\"); The method does not give any feedback on whether the message could be delivered. However, it can throw an exception if the local node has no connection to the drasyl network. Receiving Messages \u00b6 Each received message is announced as an MessageEvent to the application. The event contains a pair with sender and payload of the message. Example: ... public void onEvent(Event event) { if (event instanceof MessageEvent) { MessageEvent message = (MessageEvent) event; System.out.println(\"Message received from \" + message.getSender() + \" with payload \" + message.getPayload()); } } ... Starting & Stopping the drasyl Node \u00b6 Before you can use the drasyl node, you must start it using node.start() . For communication with other nodes in the local network, the node starts a server listening on port 22527. Make sure that the port is available. After the node has been successfully started, it emits an NodeUpEvent to the application. Then, once it has successfully connected to the overlay network, an NodeOnlineEvent is emitted. If the node is temporarily or permanently no longer needed, it can be shut down using node.shutdown() . An NodeDownEvent is emitted immediately after this call. The application should now no longer attempt to send messages. As soon as the connection to the drasyl network is terminated, an NodeOfflineEvent is emitted. An NodeNormalTerminationEvent is created when the shutdown is done.","title":"Quick Start"},{"location":"getting-started/quick-start/#quick-start","text":"Nightly Version You're currently on a nightly version branch. If you're only interested in the latest stable version, please click here . This guide describes the necessary steps to create your first drasyl node and how to integrate it into your application. Once the node is set up, it and therefore your application can participate in the drasyl Overlay Network and communicate with other nodes and applications.","title":"Quick Start"},{"location":"getting-started/quick-start/#add-snapshot-repository","text":"<repositories> <repository> <id>oss.sonatype.org-snapshot</id> <url>https://oss.sonatype.org/content/repositories/snapshots/</url> <releases> <enabled>false</enabled> </releases> <snapshots> <enabled>true</enabled> </snapshots> </repository> </repositories>","title":"Add Snapshot Repository"},{"location":"getting-started/quick-start/#add-dependency","text":"Maven: <dependency> <groupId>org.drasyl</groupId> <artifactId>drasyl-core</artifactId> <version>0.2.1-SNAPSHOT</version> </dependency> Gradle: compile group: 'org.drasyl', name: 'drasyl-core', version: '0.2.1-SNAPSHOT'","title":"Add Dependency"},{"location":"getting-started/quick-start/#implementing-drasylnode","text":"Next, you can create your own drasyl node by implementing DrasylNode . This class contains the following methods that are now relevant for you: send(...) : allows your application to send arbitrary messages to other drasyl nodes. onEvent(...) : allows your application to react to certain events (e.g. process received messages). This method must be implemented. start() : starts the node, which will then automatically connect to the drasyl network. shutdown() : disconnects from the drasyl network and shuts down the node. Here you can see a minimal working example of a node that forwards all received events to System.out : DrasylNode node = new DrasylNode() { @Override public void onEvent(Event event) { System.out.println(\"Event received: \" + event); } };","title":"Implementing DrasylNode"},{"location":"getting-started/quick-start/#node-events","text":"As mentioned before, different events are received by the application. These provide information about the state of your node, received messages or connections to other nodes. It is therefore important that you become familiar with the definitions and implications of the different event types. For example, you should listen for NodeOnlineEvent before start sending messages, and pause when NodeOfflineEvent has been received. Advanced References If you are interested in the life cycle of the individual events, you can find a state diagram here .","title":"Node Events"},{"location":"getting-started/quick-start/#sending-messages","text":"Every message that is to be sent requires a recipient address. Each drasyl node creates an identity at its first startup consisting of a cryptographic public-private key pair. From the public key, a 10 hex digit address is derived, by which each node can be uniquely identified. Currently, addresses of recipient nodes must be known, as drasyl currently has no function for querying available addresses. The send() method needs the recipient as first argument and the message payload as second argument. Example node.send(\"0229041b273dd5ee1c2bef2d77ae17dbd00d2f0a2e939e22d42ef1c4bf05147ea9\", \"Hello World\"); The method does not give any feedback on whether the message could be delivered. However, it can throw an exception if the local node has no connection to the drasyl network.","title":"Sending Messages"},{"location":"getting-started/quick-start/#receiving-messages","text":"Each received message is announced as an MessageEvent to the application. The event contains a pair with sender and payload of the message. Example: ... public void onEvent(Event event) { if (event instanceof MessageEvent) { MessageEvent message = (MessageEvent) event; System.out.println(\"Message received from \" + message.getSender() + \" with payload \" + message.getPayload()); } } ...","title":"Receiving Messages"},{"location":"getting-started/quick-start/#starting-stopping-the-drasyl-node","text":"Before you can use the drasyl node, you must start it using node.start() . For communication with other nodes in the local network, the node starts a server listening on port 22527. Make sure that the port is available. After the node has been successfully started, it emits an NodeUpEvent to the application. Then, once it has successfully connected to the overlay network, an NodeOnlineEvent is emitted. If the node is temporarily or permanently no longer needed, it can be shut down using node.shutdown() . An NodeDownEvent is emitted immediately after this call. The application should now no longer attempt to send messages. As soon as the connection to the drasyl network is terminated, an NodeOfflineEvent is emitted. An NodeNormalTerminationEvent is created when the shutdown is done.","title":"Starting &amp; Stopping the drasyl Node"},{"location":"getting-started/super-peers/","text":"Super Peers \u00b6 The following super-peers are public available: Endpoint Network ID Used drasyl version wss://production.env.drasyl.org#025fff6f625f5dee816d9f8fe43895479aecfda187cb6a3330894a07e698bc5bd8 1 Latest stable release wss://staging.env.drasyl.org#03096ae3080a369829a44847d5af1f652bef3f9921e9e1bbad64970babe6d3c502 -25421 Latest nightly","title":"Super-Peers"},{"location":"getting-started/super-peers/#super-peers","text":"The following super-peers are public available: Endpoint Network ID Used drasyl version wss://production.env.drasyl.org#025fff6f625f5dee816d9f8fe43895479aecfda187cb6a3330894a07e698bc5bd8 1 Latest stable release wss://staging.env.drasyl.org#03096ae3080a369829a44847d5af1f652bef3f9921e9e1bbad64970babe6d3c502 -25421 Latest nightly","title":"Super Peers"}]}