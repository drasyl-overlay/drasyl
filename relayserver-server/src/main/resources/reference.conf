relay {
  # Sets the Channel Initalizer for netty
  channel_initializer = "city.sane.relay.server.handler.RelayServerInitializer"
  version = ${project.version}
  # User-Agent string of this relay
  user-agent = "${project.groupId}:${project.artifactId}/${version}~${git.commit.id.abbrev}"
  # The maximum length of the aggregated content in bytes
  max_content_length = 1M
  # If no channel is set on join, this channel will be assigned to the session
  default_channel = "default"
  # Default timeout for futures. If a future is not fulfilled in this
  # time, it throws an exception.
  default_future_timeout = 30 s
  # The maximum time a client has to send a
  # {@link city.sane.relay.common.messages.JoinMessage JoinMessage} before the
  # connection is closed again.
  max_handshake_timeout = 30 s
  # The maximum amount of hops, before a forwardable p2p message is dropped (cycle detection)
  max_hop_count = 20
  # Maximum amount of retries to etablish a connection to a peer
  connection_tries = 3
  # The maximum time a peer has to send a p2p message before the future is canceled
  default_p2p_timeout = 10 s
  # The initial list of known relay peers as ip:port string
  init_peer_list = []
  # The maximum time a client has to make a successful handoff before
  # the old relay is terminating the connection.
  max_handoff_timeout = 30 s
  # The maximum amount of message in the message bucket (for duplicate detection)
  msg_bucket_limit = 50000
  # If enabled, the relay runs in debugging mode (e.g. it uses other directories for monitoring)
  debugging = false
  monitoring {
    enabled = false
    # Token to access the monitoring
    token = "changeMeWhenInProduction"
    # Port for the monitoring page
    port = 8080
    # Path for the websocket connection
    websocket_path = "/websocket"
    # The time, how long a dead client should be saved in a list for the monitoring overview page
    dead_clients_saving_time = 30 m
  }
  ssl {
    enabled = false
    protocols = ["TLSv1.3", "TLSv1.2"]
  }
  # The size of the flush buffer, to minimize IO overhead.
  # A high value is good for throughput.
  # A low value is good for latency.
  flush_buffer_size = 256
  # For the total time, a connection can be in idle, you have to multiply
  # ${idle.max_idle_time}*${idle.retries}
  idle {
    # The maximum time that an active connection can spend in idle
    # before the relay checks with a PING request whether the remote station is still alive.
    # Note: every long value <= 0 s deactivates the idle function.
    timeout = 1 m
    # The maximum amount that a remote station cannot reply to a PING request
    # in succession in the interval ${max_idle_time}.
    # Min value is 1, max 32767
    retries = 3
  }
}
